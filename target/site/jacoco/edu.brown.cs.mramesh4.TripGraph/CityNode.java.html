<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CityNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">TripFinder</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.mramesh4.TripGraph</a> &gt; <span class="el_source">CityNode.java</span></div><h1>CityNode.java</h1><pre class="source lang-java linenums">package edu.brown.cs.mramesh4.TripGraph;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

/**
 * This is a class to model our CityNodes: CityNodes are nodes that represent
 * a point on our Graph. Each point on the graph can calculate distances
 * between other cities as well as store information about itself.
 */
public class CityNode implements TripGraphNode&lt;CityNode, CityEdge&gt; {
  private String name;
  private double lat;
  private double longit;
  private HashMap&lt;String, CityNode&gt; connectingNodes;
  private HashMap&lt;String, CityEdge&gt; connectingEdges;
  private double weight;
  private double distance;
  private static final double EARTH_RADIUS_IN_KM = 6371;

  /**
   * This is a constructor for a cityNode. A cityNode right now takes in
   * a name, a latitude and a longitude.
   * @param name  Name of city that will be stored in graph
   * @param lat  Latitude of city
   * @param lon  Longitude of city
   */
<span class="fc" id="L30">  public CityNode(String name, double lat, double lon) {</span>
<span class="fc" id="L31">    this.name = name;</span>
<span class="fc" id="L32">    this.lat = lat;</span>
<span class="fc" id="L33">    this.longit = lon;</span>
<span class="fc" id="L34">    connectingNodes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L35">    connectingEdges = new HashMap&lt;&gt;();</span>
<span class="fc" id="L36">    this.weight = Double.MAX_VALUE;</span>
<span class="fc" id="L37">    this.distance = Double.MAX_VALUE;</span>
<span class="fc" id="L38">  }</span>
  /**
   * Returns the name of the cityNode.
   * @return The name of the City
   */
  public String getName() {
<span class="fc" id="L44">    return name;</span>
  }
  /**
   * Returns the latitude of the city.
   * @return The lat of the city
   */
  public double getLat() {
<span class="fc" id="L51">    return lat;</span>
  }
  /**
   * Returns the longitude of the city.
   * @return The longitude of the city
   */

  public double getLong() {
<span class="fc" id="L59">    return longit;</span>
  }

  /**
   * Returns the weight of the node for algorithms.
   * @return weight
   */
  @Override
  public double getWeight() {
<span class="fc" id="L68">    return weight;</span>
  }

  /**
   * Setter method for distance.
   * @param dist distance to set the distance to.
   */
  @Override
  public void setDistance(double dist) {
<span class="fc" id="L77">    distance = dist;</span>
<span class="fc" id="L78">  }</span>

  @Override
  public double getDistance() {
<span class="fc" id="L82">    return distance;</span>
  }

  /**
   * Setter method for weight.
   * @param weight weight to set the weight to.
   */
  public void setWeight(double weight) {
<span class="fc" id="L90">    this.weight = weight;</span>
<span class="fc" id="L91">  }</span>

  /**
   * Accessor method for the nodes map.
   * @return map of nodes
   */
  public HashMap&lt;String, CityNode&gt; getConnectingNodes() {
<span class="fc" id="L98">    return connectingNodes;</span>
  }

  /**
   * Accessor method for edges between nodes (undirected).
   * @return a Map of edges
   */
  public HashMap&lt;String, CityEdge&gt; getConnectingEdges() {
<span class="fc" id="L106">    return connectingEdges;</span>
  }
  /**
   * This is a comparator method that takes in a GraphNode and tells us if the two cities are equal.
   * If the GraphNode is not a cityNode we return false due to comparison errors.
   * @return Boolean representing if nodes are the same node
   */
  @Override
  public boolean equals(CityNode node) {
<span class="pc bpc" id="L115" title="1 of 4 branches missed.">    return name.equals(node.getName()) &amp;&amp; (lat == node.getLat())</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">      &amp;&amp; (longit ==  node.getLong());</span>
  }

  /**
   * This is a method that insertsEdges between the node. Since
   * we have an undirected graph it will reinsert.
   * @param node node to insert edges between
   */
  @Override
  public void insertEdges(CityNode node) {
<span class="pc bpc" id="L126" title="2 of 4 branches missed.">    if (node != null &amp;&amp; !node.equals(this)) {</span>
<span class="fc" id="L127">      String name = node.getName();</span>
<span class="fc" id="L128">      String edgeName = this.name + &quot;-&gt;&quot; + node.getName();</span>
<span class="fc" id="L129">      CityEdge edge = new CityEdge(this, node, edgeName);</span>
<span class="fc" id="L130">      CityEdge edge2 = new CityEdge(node, this, edgeName);</span>
<span class="fc" id="L131">      connectingNodes.put(name, node);</span>
<span class="fc" id="L132">      connectingEdges.put(name, edge);</span>
<span class="fc" id="L133">      node.getConnectingNodes().put(this.name, this);</span>
<span class="fc" id="L134">      node.getConnectingEdges().put(this.name, edge2);</span>
    }
<span class="fc" id="L136">  }</span>

  /**
   * This is a method that deletes an edge between two nodes.
   * @param node edge to delete between two edges
   */
  @Override
  public void deleteEdge(CityNode node) {
<span class="fc" id="L144">    String name = node.getName();</span>
<span class="fc" id="L145">    connectingNodes.remove(name);</span>
<span class="fc" id="L146">    connectingEdges.remove(name);</span>
<span class="fc" id="L147">    node.getConnectingNodes().remove(this.name);</span>
<span class="fc" id="L148">    node.getConnectingEdges().remove(this.name);</span>
<span class="fc" id="L149">  }</span>

  /**
   * This is a method that clears all the graph edges and graph nodes
   */
  @Override
  public void clearGraphEdges() {
<span class="fc" id="L156">    connectingNodes.clear();</span>
<span class="fc" id="L157">    connectingEdges.clear();</span>
<span class="fc" id="L158">  }</span>


  /**
   * Returns the euclidean distance between two city nodes.
   * @param a a node to check distance from
   * @return distance between two cities
   */
  @Override
  public double distanceBetween(CityNode a) {
<span class="fc" id="L168">    double aX = a.getLong();</span>
<span class="fc" id="L169">    double aY = a.getLat();</span>
<span class="fc" id="L170">    return Math.sqrt(Math.pow(Math.abs((aX - this.longit)), 2)</span>
<span class="fc" id="L171">      + Math.pow(Math.abs((aY - this.lat)), 2));</span>
  }

  /**
   * Returns a list of outgoing edges.
   * @return a list of outgoing edges.
   */
  @Override
  public List&lt;CityEdge&gt; getOutgoingEdges() {
<span class="fc" id="L180">    Collection&lt;CityEdge&gt; c  = this.getConnectingEdges().values();</span>
<span class="fc" id="L181">    List&lt;CityEdge&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">    for (CityEdge edge: c) {</span>
<span class="fc" id="L183">      ret.add(edge);</span>
<span class="fc" id="L184">    }</span>
<span class="fc" id="L185">    return ret;</span>
  }

  /**
   * Returns a list of neighbors.
   * @return nodes of neighbors.
   */
  @Override
  public List&lt;CityNode&gt; getNeighbors() {
<span class="fc" id="L194">    Collection&lt;CityNode&gt; c  = this.getConnectingNodes().values();</span>
<span class="fc" id="L195">    List&lt;CityNode&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">    for (CityNode node: c) {</span>
<span class="fc" id="L197">      ret.add(node);</span>
<span class="fc" id="L198">    }</span>
<span class="fc" id="L199">    return ret;</span>
  }

  /**
   * This is for the aStar heuristic, using haversine distance.
   * @param goal goal to check from
   * @return a double for the A* function
   */
  @Override
  public double toGoal(CityNode goal) {
<span class="fc" id="L209">    double thisLat = Math.toRadians(lat);</span>
<span class="fc" id="L210">    double thisLon = Math.toRadians(longit);</span>
<span class="fc" id="L211">    double goalLat = Math.toRadians(goal.getLat());</span>
<span class="fc" id="L212">    double goalLon = Math.toRadians(goal.getLong());</span>
    /**
     * Haversine formula: I got this from
     * https://www.geeksforgeeks.org/program-distance-two-points-earth/
     */
<span class="fc" id="L217">    double dlon = goalLon - thisLon;</span>
<span class="fc" id="L218">    double dlat = goalLat - thisLat;</span>
<span class="fc" id="L219">    double havernmath = Math.pow(Math.sin(dlat / 2), 2)</span>
<span class="fc" id="L220">        + Math.cos(thisLat) * Math.cos(goalLat)</span>
<span class="fc" id="L221">        * Math.pow(Math.sin(dlon / 2), 2);</span>
<span class="fc" id="L222">    double finalanswer = 2 * Math.asin(Math.sqrt(havernmath));</span>
    // Radius of earth in kilometers. Use 3956 for miles
<span class="fc" id="L224">    return (finalanswer * EARTH_RADIUS_IN_KM);</span>
  }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>