<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MinMatchCostMatrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">TripFinder</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.mramesh4.TripGraph</a> &gt; <span class="el_source">MinMatchCostMatrix.java</span></div><h1>MinMatchCostMatrix.java</h1><pre class="source lang-java linenums">package edu.brown.cs.mramesh4.TripGraph;

import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * This is a class to take a double matrix of costs and make assignments
 * between the rows and cols.
 * The class draws heavy inspiration from two sources.
 *   1) https://www.youtube.com/watch?v=SAPG2T4Jbok: This is not a code
 *   base but rather a video that explains steps of the hungarian algorithm.
 *   Online implementations of the Hungarian algorithm: including
 *      https://www.sanfoundry.com/java-program-implement-hungarian-algorithm-bipartite-matching/
 *      https://github.com/aalmi/HungarianAlgorithm/blob/master/HungarianAlgorithm.java
 *
 */
public class MinMatchCostMatrix {
  double[][] matrix; // this is a cost matrix
  // these are the markers required for the hungarian algorithm.
  int[] squareR, squareC, rowIsCovered, colIsCovered, staredZeroesInRow;

  /**
   * This is a constructor for the minCostMatrix, we will build the identifiers
   * needed to run the hungarian algorithm
   * @param matrix a cost matrix of doubles
   */
<span class="fc" id="L28">  public MinMatchCostMatrix(double[][]matrix) {</span>
<span class="fc" id="L29">    this.matrix = matrix;</span>
<span class="fc" id="L30">    squareR = new int[matrix.length];</span>
<span class="fc" id="L31">    squareC = new int[matrix[0].length];</span>

<span class="fc" id="L33">    rowIsCovered = new int[matrix.length];</span>
<span class="fc" id="L34">    colIsCovered = new int[matrix[0].length];</span>
<span class="fc" id="L35">    staredZeroesInRow = new int[matrix.length];</span>
<span class="fc" id="L36">    Arrays.fill(staredZeroesInRow, -1);</span>
<span class="fc" id="L37">    Arrays.fill(squareR, -1);</span>
<span class="fc" id="L38">    Arrays.fill(squareC, -1);</span>
<span class="fc" id="L39">  }</span>

  /**
   * This fills a new matrix with optimal assignments between the two.
   * This is the Hungarian algorithm, and mostly utilizes what was explained
   * in the Youtube video.
   *
   * @return optimal assignment
   */
  public int[][] findOptimalAssignment() {

    //these are the 1st 3 steps of the hungarian algorithm
<span class="fc" id="L51">    step1();    // reduce matrix</span>
<span class="fc" id="L52">    step2();    // mark independent zeroes</span>
<span class="fc" id="L53">    step3();    // cover columns which contain a marked zero</span>

    //this allows us to jump steps
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">    while (!allColumnsAreCovered()) {</span>
<span class="nc" id="L57">      int[] mainZero = step4();</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">      while (mainZero == null) {</span>
<span class="nc" id="L59">        step7();</span>
<span class="nc" id="L60">        mainZero = step4();</span>
      }
<span class="nc bnc" id="L62" title="All 2 branches missed.">      if (squareR[mainZero[0]] == -1) {</span>
<span class="nc" id="L63">        step6(mainZero);</span>
<span class="nc" id="L64">        step3();</span>
      } else {
<span class="nc" id="L66">        rowIsCovered[mainZero[0]] = 1;  // cover row of mainZero</span>
<span class="nc" id="L67">        colIsCovered[squareR[mainZero[0]]] = 0;  // uncover column of mainZero</span>
<span class="nc" id="L68">        step7();</span>
      }
<span class="nc" id="L70">    }</span>

<span class="fc" id="L72">    int[][] optimalAssignment = new int[matrix.length][];</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">    for (int i = 0; i &lt; squareC.length; i++) {</span>
<span class="fc" id="L74">      optimalAssignment[i] = new int[]{i, squareC[i]};</span>
    }
<span class="fc" id="L76">    return optimalAssignment;</span>
  }

  /**
   * Check if all columns are covered. If that's the case then the
   * optimal solution is found
   *
   * @return boolean
   */
  private boolean allColumnsAreCovered() {
<span class="fc bfc" id="L86" title="All 2 branches covered.">    for (int i : colIsCovered) {</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">      if (i == 0) {</span>
<span class="nc" id="L88">        return false;</span>
      }
    }
<span class="fc" id="L91">    return true;</span>
  }

  /**
   * Step 1: This is step1 of the Hungarian algorithm it does the following:
   * 1. subtract each row minima from each element of the row
   * 2. subtract each column minima from each element of the column
   */
  private void step1() {
    // rows
<span class="fc bfc" id="L101" title="All 2 branches covered.">    for (int i = 0; i &lt; matrix.length; i++) {</span>
      // find the min value of the current row
<span class="fc" id="L103">      double currentRowMin = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">      for (int j = 0; j &lt; matrix[i].length; j++) {</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (matrix[i][j] &lt; currentRowMin) {</span>
<span class="fc" id="L106">          currentRowMin = matrix[i][j];</span>
        }
      }
      // subtract min value from each element of the current row
<span class="fc bfc" id="L110" title="All 2 branches covered.">      for (int k = 0; k &lt; matrix[i].length; k++) {</span>
<span class="fc" id="L111">        matrix[i][k] -= currentRowMin;</span>
      }
    }

    // cols
<span class="fc bfc" id="L116" title="All 2 branches covered.">    for (int i = 0; i &lt; matrix[0].length; i++) {</span>
      // find the min value of the current column
<span class="fc" id="L118">      double currentColMin = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">      for (int j = 0; j &lt; matrix.length; j++) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (matrix[j][i] &lt; currentColMin) {</span>
<span class="fc" id="L121">          currentColMin = matrix[j][i];</span>
        }
      }
      // subtract min value from each element of the current column
<span class="fc bfc" id="L125" title="All 2 branches covered.">      for (int k = 0; k &lt; matrix.length; k++) {</span>
<span class="fc" id="L126">        matrix[k][i] -= currentColMin;</span>
      }
    }
<span class="fc" id="L129">  }</span>

  /**
   * Step 2:
   * mark each 0 with a &quot;square&quot;, if there are no other marked zeroes in the same row or column
   */
  private void step2() {
<span class="fc" id="L136">    int[] rowHasSquare = new int[matrix.length];</span>
<span class="fc" id="L137">    int[] colHasSquare = new int[matrix[0].length];</span>

<span class="fc bfc" id="L139" title="All 2 branches covered.">    for (int i = 0; i &lt; matrix.length; i++) {</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">      for (int j = 0; j &lt; matrix.length; j++) {</span>
        // mark if current value == 0 &amp; there are no other marked zeroes in the same row or column
<span class="pc bpc" id="L142" title="2 of 6 branches missed.">        if (matrix[i][j] == 0 &amp;&amp; rowHasSquare[i] == 0 &amp;&amp; colHasSquare[j] == 0) {</span>
<span class="fc" id="L143">          rowHasSquare[i] = 1;</span>
<span class="fc" id="L144">          colHasSquare[j] = 1;</span>
<span class="fc" id="L145">          squareR[i] = j;</span>
<span class="fc" id="L146">          squareC[j] = i;</span>
          continue;
        }
      }
    }
<span class="fc" id="L151">  }</span>

  /**
   * Step 3:
   * Cover all columns which are marked with a &quot;square&quot;
   */
  private void step3() {
<span class="fc bfc" id="L158" title="All 2 branches covered.">    for (int i = 0; i &lt; squareC.length; i++) {</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">      colIsCovered[i] = squareC[i] != -1 ? 1 : 0;</span>
    }
<span class="fc" id="L161">  }</span>

  /**
   * Step 7:
   * 1. Find the smallest uncovered value in the matrix.
   * 2. Subtract it from all uncovered values
   * 3. Add it to all twice-covered values
   */
  private void step7() {
    // Find the smallest uncovered value in the matrix
<span class="nc" id="L171">    double minUncoveredValue = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">    for (int i = 0; i &lt; matrix.length; i++) {</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">      if (rowIsCovered[i] == 1) {</span>
<span class="nc" id="L174">        continue;</span>
      }
<span class="nc bnc" id="L176" title="All 2 branches missed.">      for (int j = 0; j &lt; matrix[0].length; j++) {</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">        if (colIsCovered[j] == 0 &amp;&amp; matrix[i][j] &lt; minUncoveredValue) {</span>
<span class="nc" id="L178">          minUncoveredValue = matrix[i][j];</span>
        }
      }
    }

<span class="nc bnc" id="L183" title="All 2 branches missed.">    if (minUncoveredValue &gt; 0) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">      for (int i = 0; i &lt; matrix.length; i++) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        for (int j = 0; j &lt; matrix[0].length; j++) {</span>
<span class="nc bnc" id="L186" title="All 4 branches missed.">          if (rowIsCovered[i] == 1 &amp;&amp; colIsCovered[j] == 1) {</span>
            // Add min to all twice-covered values
<span class="nc" id="L188">            matrix[i][j] += minUncoveredValue;</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">          } else if (rowIsCovered[i] == 0 &amp;&amp; colIsCovered[j] == 0) {</span>
            // Subtract min from all uncovered values
<span class="nc" id="L191">            matrix[i][j] -= minUncoveredValue;</span>
          }
        }
      }
    }
<span class="nc" id="L196">  }</span>

  /**
   * Step 4:
   * Find zero value Z_0 and mark it as &quot;0*&quot;.
   *
   * @return position of Z_0 in the matrix
   */
  private int[] step4() {
<span class="nc bnc" id="L205" title="All 2 branches missed.">    for (int i = 0; i &lt; matrix.length; i++) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">      if (rowIsCovered[i] == 0) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        for (int j = 0; j &lt; matrix[i].length; j++) {</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">          if (matrix[i][j] == 0 &amp;&amp; colIsCovered[j] == 0) {</span>
<span class="nc" id="L209">            staredZeroesInRow[i] = j; // mark as 0*</span>
<span class="nc" id="L210">            return new int[]{i, j};</span>
          }
        }
      }
    }
<span class="nc" id="L215">    return null;</span>
  }

  /**
   * Step 6:
   * Create a chain K of alternating &quot;squares&quot; and &quot;0*&quot;
   *
   * @param mainZero =&gt; Z_0 of Step 4
   */
  private void step6(int[] mainZero) {
<span class="nc" id="L225">    int i = mainZero[0];</span>
<span class="nc" id="L226">    int j = mainZero[1];</span>

<span class="nc" id="L228">    Set&lt;int[]&gt; K = new LinkedHashSet&lt;&gt;();</span>
    //(a)
    // add Z_0 to K
<span class="nc" id="L231">    K.add(mainZero);</span>
<span class="nc" id="L232">    boolean found = false;</span>
    do {
      // (b)
      // add Z_1 to K if
      // there is a zero Z_1 which is marked with a &quot;square &quot; in the column of Z_0
<span class="nc bnc" id="L237" title="All 2 branches missed.">      if (squareC[j] != -1) {</span>
<span class="nc" id="L238">        K.add(new int[]{squareC[j], j});</span>
<span class="nc" id="L239">        found = true;</span>
      } else {
<span class="nc" id="L241">        found = false;</span>
      }

      // if no zero element Z_1 marked with &quot;square&quot; exists in the column of Z_0, then cancel the loop
<span class="nc bnc" id="L245" title="All 2 branches missed.">      if (!found) {</span>
<span class="nc" id="L246">        break;</span>
      }

      // (c)
      // replace Z_0 with the 0* in the row of Z_1
<span class="nc" id="L251">      i = squareC[j];</span>
<span class="nc" id="L252">      j = staredZeroesInRow[i];</span>
      // add the new Z_0 to K
<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (j != -1) {</span>
<span class="nc" id="L255">        K.add(new int[]{i, j});</span>
<span class="nc" id="L256">        found = true;</span>
      } else {
<span class="nc" id="L258">        found = false;</span>
      }

<span class="nc bnc" id="L261" title="All 2 branches missed.">    } while (found); // (d) as long as no new &quot;square&quot; marks are found</span>

    // (e)
<span class="nc bnc" id="L264" title="All 2 branches missed.">    for (int[] zero : K) {</span>
      // remove all &quot;square&quot; marks in K
<span class="nc bnc" id="L266" title="All 2 branches missed.">      if (squareC[zero[1]] == zero[0]) {</span>
<span class="nc" id="L267">        squareC[zero[1]] = -1;</span>
<span class="nc" id="L268">        squareR[zero[0]] = -1;</span>
      }
      // replace the 0* marks in K with &quot;square&quot; marks
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (staredZeroesInRow[zero[0]] == zero[1]) {</span>
<span class="nc" id="L272">        squareR[zero[0]] = zero[1];</span>
<span class="nc" id="L273">        squareC[zero[1]] = zero[0];</span>
      }
<span class="nc" id="L275">    }</span>

<span class="nc" id="L277">    Arrays.fill(staredZeroesInRow, -1);</span>
<span class="nc" id="L278">    Arrays.fill(rowIsCovered, 0);</span>
<span class="nc" id="L279">    Arrays.fill(colIsCovered, 0);</span>
<span class="nc" id="L280">  }</span>



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>