<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapsLogic.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">TripFinder</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.mramesh4.maps</a> &gt; <span class="el_source">MapsLogic.java</span></div><h1>MapsLogic.java</h1><pre class="source lang-java linenums">package edu.brown.cs.mramesh4.maps;

import edu.brown.cs.mramesh4.Graph.Graph;
import edu.brown.cs.mramesh4.KDTree.KDTree;
import edu.brown.cs.mramesh4.stars.ActionMethod;
import edu.brown.cs.mramesh4.stars.IllegalArgumentException;
import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.ResultSetMetaData;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;

/**
 * This class represents all of the logic we need for Maps 1 + 2. It handles all finding which
 * command to call, getting a connection to the database, and calling commands and the necessary
 * helper methods to complete them. It also handles parsing the output to print in the terminal.
 */
public class MapsLogic implements ActionMethod&lt;String&gt; {

  private List&lt;WayNodes&gt; wayNodeList;
  private KDTree&lt;WayNodes&gt; wayNodesTree;
<span class="nc" id="L29">  private Connection conn = null;</span>
<span class="nc" id="L30">  private Graph&lt;WayNodes, Way&gt; graph = new Graph&lt;&gt;();</span>
  private WayNodeCache wnc;
<span class="nc" id="L32">  private HashMap&lt;String, WayNodes&gt; wayNodeCache = new HashMap&lt;&gt;();</span>
  private String database;

  /**
   * In the constructor of MapsLogic, we initailize our list instance variable which holds
   * all the nodes in the database.
   */
<span class="nc" id="L39">  public MapsLogic() {</span>
<span class="nc" id="L40">    wayNodeList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L41">  }</span>

  /**
   * Takes in a command from the command line and executes it.
   * @param coms String from the command line
   */
  @Override
  public void run(String[] coms) {
    //assuming the length &gt; 0
<span class="nc bnc" id="L50" title="All 2 branches missed.">    if (coms.length &gt; 0) {</span>
      //run regardless of uppercase and trimmed space
<span class="nc bnc" id="L52" title="All 5 branches missed.">      switch (coms[0]) {</span>
        case &quot;map&quot;:
<span class="nc" id="L54">          this.map(coms);</span>
<span class="nc" id="L55">          break;</span>
        case &quot;ways&quot;:
<span class="nc" id="L57">          this.ways(coms);</span>
<span class="nc" id="L58">          break;</span>
        case &quot;nearest&quot;:
<span class="nc" id="L60">          this.nearest(coms);</span>
<span class="nc" id="L61">          break;</span>
        case &quot;route&quot;:
<span class="nc" id="L63">          this.route(coms);</span>
<span class="nc" id="L64">          break;</span>
        default:
<span class="nc" id="L66">          System.err.println(&quot;ERROR: You entered&quot; + coms[0] + &quot;Please enter a valid command&quot;);</span>
          break;
      }
    }
<span class="nc" id="L70">  }</span>

  /**
   * Loads the map database and builds our KDTree.
   * @param coms whitesace separated list of arguments.
   */
  public void map(String[] coms) {
    //checking that command has correct number of args
<span class="nc bnc" id="L78" title="All 2 branches missed.">    if (coms.length != 2) {</span>
<span class="nc" id="L79">      System.err.println(&quot;ERROR: Incorrect number or args provided for map command&quot;);</span>
<span class="nc" id="L80">      return;</span>
    }
<span class="nc" id="L82">    File file = new File(coms[1]);</span>
    //check to see if database file exists
<span class="nc bnc" id="L84" title="All 2 branches missed.">    if (!file.exists()) {</span>
<span class="nc" id="L85">      System.err.println(&quot;ERROR: File does not exist&quot;);</span>
      //make sure file is valid
<span class="nc" id="L87">      return;</span>
    }
    try {
<span class="nc" id="L90">      Class.forName(&quot;org.sqlite.JDBC&quot;);</span>
<span class="nc" id="L91">      String pathToDB = &quot;jdbc:sqlite:&quot; + coms[1];</span>
      //create a connection
<span class="nc" id="L93">      conn = DriverManager.getConnection(pathToDB);</span>
<span class="nc" id="L94">      String[] tables = new String[]{&quot;node&quot;, &quot;way&quot;};</span>
<span class="nc" id="L95">      String[] expectedCols = new String[]{&quot;id&quot;, &quot;latitude&quot;, &quot;longitude&quot;};</span>
      //makes sure our table we are reading from exists
<span class="nc bnc" id="L97" title="All 2 branches missed.">      if (isValidTable(tables)) {</span>
        PreparedStatement prep;
        //get all of the nodes table

<span class="nc" id="L101">        prep = conn.prepareStatement(&quot;WITH trav as (SELECT start AS node_id &quot;</span>
                + &quot;from way WHERE type != \&quot;\&quot; and type != \&quot;unclassified\&quot;&quot;
          + &quot;UNION SELECT end AS node from way WHERE type != \&quot;\&quot; and type != \&quot;unclassified\&quot;)&quot;
          + &quot;SELECT id, latitude, longitude FROM trav JOIN node on trav.node_id == node.id&quot;);
<span class="nc" id="L105">        ResultSet rs = prep.executeQuery();</span>
<span class="nc" id="L106">        wayNodeList.clear();</span>
        //makes sure our table is correctly columned
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (!isValidQuery(rs, expectedCols)) {</span>
<span class="nc" id="L109">          System.err.println(&quot;ERROR: Table is ill-formated&quot;);</span>
<span class="nc" id="L110">          return;</span>
        } else {
<span class="nc bnc" id="L112" title="All 2 branches missed.">          while (rs.next()) {</span>
            //create a Node object for each entry in table
<span class="nc" id="L114">            String id = rs.getString(1);</span>
<span class="nc" id="L115">            double latitude = rs.getDouble(2);</span>
<span class="nc" id="L116">            double longitude = rs.getDouble(3);</span>

            //we want to make sure this is valid and that the table is well formatted. If
            //it isn't we throw an error.
<span class="nc" id="L120">            WayNodes wayNode = new WayNodes(id, latitude, longitude, conn);</span>
<span class="nc" id="L121">            wayNodeList.add(wayNode);</span>
<span class="nc" id="L122">          }</span>
<span class="nc" id="L123">          rs.close();</span>
          //create KDTree with the wayNode List we creaed
<span class="nc" id="L125">          wayNodesTree = new KDTree&lt;WayNodes&gt;(wayNodeList, 2);</span>
<span class="nc" id="L126">          graph = new Graph&lt;WayNodes, Way&gt;();</span>
<span class="nc" id="L127">          wnc = new WayNodeCache(this.conn);</span>
<span class="nc" id="L128">          wayNodeCache = new HashMap&lt;&gt;();</span>
<span class="nc" id="L129">          System.out.println(&quot;map set to &quot; + coms[1]);</span>
        }
<span class="nc" id="L131">      } else {</span>
<span class="nc" id="L132">        System.err.println(&quot;ERROR: Table is ill-formated&quot;);</span>
      }
<span class="nc" id="L134">    } catch (SQLException e) {</span>
<span class="nc" id="L135">      System.err.println(&quot;ERROR: Error connecting to database&quot;);</span>
<span class="nc" id="L136">      return;</span>
<span class="nc" id="L137">    } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L138">      System.err.println(&quot;ERROR: Invalid database class&quot;);</span>
<span class="nc" id="L139">      return;</span>
<span class="nc" id="L140">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L141">      System.err.println(&quot;ERROR: Ill-formatted database&quot;);</span>
<span class="nc" id="L142">      return;</span>
<span class="nc" id="L143">    }</span>
<span class="nc" id="L144">  }</span>
  /**
   * Accessor method for wayNodeList.
   * @return list of waynodes
   */
  public List&lt;WayNodes&gt; getWayNodeList() {
<span class="nc" id="L150">    return this.wayNodeList;</span>
  }

  /**
   * Tells us if a given table name exists in our connection.
   * @param tablename name of table to search
   * @return a boolean if table exists
   */
  public boolean isValidTable(String[] tablename) {
    try {
<span class="nc bnc" id="L160" title="All 2 branches missed.">      for (int i = 0; i &lt; tablename.length; i++) {</span>
<span class="nc" id="L161">        boolean exist = conn.getMetaData().getTables(null,</span>
<span class="nc" id="L162">                null, tablename[i], null).next();</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (!exist) {</span>
<span class="nc" id="L164">          return false;</span>
        }
      }
<span class="nc" id="L167">      return true;</span>
<span class="nc" id="L168">    } catch (SQLException e) {</span>
<span class="nc" id="L169">      System.out.println(&quot;Table SQL Exception&quot;);</span>
<span class="nc" id="L170">      return false;</span>
    }
  }

  /**
   * Tells us if the given query of our table has the rows we expected.
   * @param rs: ResultSet Query
   * @param expectedCols: Columns we are expecting
   * @return a boolean representing if query is valid
   */
  private boolean isValidQuery(ResultSet rs, String[] expectedCols) {
    try {
      //get the metadata of the result set
<span class="nc" id="L183">      ResultSetMetaData rsmd = rs.getMetaData();</span>
      //make sure cols match up to what we want
<span class="nc bnc" id="L185" title="All 2 branches missed.">      for (int i = 1; i &lt;= expectedCols.length; i++) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (expectedCols[i - 1].equals(rsmd.getColumnName(i))) {</span>
<span class="nc" id="L187">          continue;</span>
        } else {
<span class="nc" id="L189">          return false;</span>
        }
      }
<span class="nc" id="L192">      return true;</span>
<span class="nc" id="L193">    } catch (SQLException e) {</span>
<span class="nc" id="L194">      System.out.println(&quot;SQL Exception&quot;);</span>
<span class="nc" id="L195">      return false;</span>
    }
  }


  /**
   * This is the method to run the ways command, prints all ways within a given
   * area.
   * @param coms input to command split by white space in an array
   * @return a list of ways
   */
  public List&lt;Way&gt; ways(String[] coms) {
<span class="nc bnc" id="L207" title="All 4 branches missed.">    if (wayNodesTree == null || wayNodeList == null) {</span>
<span class="nc" id="L208">      System.err.println(&quot;ERROR: Please load a maps db into the REPL&quot;);</span>
<span class="nc" id="L209">      return null;</span>
    }
    //make sure we were passed in right arguments
<span class="nc bnc" id="L212" title="All 4 branches missed.">    if (wayNodesTree.isEmpty() || wayNodeList.isEmpty()) {</span>
<span class="nc" id="L213">      System.err.println(&quot;ERROR: Please load a maps db into the REPL&quot;);</span>
<span class="nc" id="L214">      return null;</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    } else if (coms.length != 5) {</span>
<span class="nc" id="L216">      System.err.println(&quot;ERROR: Incorrect number of args provided for ways command&quot;);</span>
<span class="nc" id="L217">      return null;</span>
    } else {
      try {
        //make sure we were passed in doubles
<span class="nc" id="L221">        double latMin = Double.parseDouble(coms[3]);</span>
<span class="nc" id="L222">        double lonMin = Double.parseDouble(coms[2]);</span>
<span class="nc" id="L223">        double latMax = Double.parseDouble(coms[1]);</span>
<span class="nc" id="L224">        double lonMax = Double.parseDouble(coms[4]);</span>
<span class="nc bnc" id="L225" title="All 4 branches missed.">        if (latMax &lt; latMin || lonMax &lt; lonMin) {</span>
<span class="nc" id="L226">          System.err.println(&quot;ERROR: Please make sure the values for &quot;</span>
                  + &quot;&lt;lat2&gt;&lt;long2&gt; are less than &lt;lat1&gt;&lt;long1&gt;&quot;);
<span class="nc" id="L228">          return null;</span>
        }
        PreparedStatement prep;
        //query the DB for all the ways within the boundaries
<span class="nc" id="L232">        prep = conn.prepareStatement(&quot;WITH s_nodes AS (SELECT id AS start_id, latitude &quot;</span>
                + &quot;AS start_lat, longitude AS start_long FROM node), &quot;
                + &quot;e_nodes AS (SELECT id AS end_id, latitude AS &quot;
                + &quot;end_lat, longitude AS end_long FROM node), &quot;
                + &quot;rel_nodes AS (SELECT id as node_id FROM node WHERE CAST(latitude AS DOUBLE) &quot;
                + &quot;BETWEEN ? AND ?  AND CAST(longitude AS DOUBLE) BETWEEN ? AND ?), &quot;
                + &quot;filtered_ways AS (SELECT * FROM way WHERE start IN rel_nodes &quot;
                + &quot;OR end IN rel_nodes) &quot;
                + &quot;SELECT * FROM filtered_ways AS fw JOIN s_nodes AS sn ON fw.start == sn.start_id &quot;
                + &quot;JOIN e_nodes AS en ON fw.end == en.end_id&quot;);
<span class="nc" id="L242">        prep.setDouble(1, latMin);</span>
<span class="nc" id="L243">        prep.setDouble(2, latMax);</span>
<span class="nc" id="L244">        prep.setDouble(3, lonMin);</span>
<span class="nc" id="L245">        prep.setDouble(4, lonMax);</span>
<span class="nc" id="L246">        ResultSet rs = prep.executeQuery();</span>

        // Processing query results
<span class="nc" id="L249">        LinkedHashSet&lt;String&gt; toPrint = new LinkedHashSet&lt;&gt;();</span>
<span class="nc" id="L250">        HashMap&lt;String, Way&gt; wayMap = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L252" title="All 2 branches missed.">        while (rs.next()) {</span>
          // way id and type
<span class="nc" id="L254">          String wayId = rs.getString(1);</span>
<span class="nc" id="L255">          String type = rs.getString(3);</span>

          // from node info
<span class="nc" id="L258">          String startId = rs.getString(4);</span>
<span class="nc" id="L259">          double startLat = rs.getDouble(7);</span>
<span class="nc" id="L260">          double startLong = rs.getDouble(8);</span>

          // to node info
<span class="nc" id="L263">          String endId = rs.getString(5);</span>
<span class="nc" id="L264">          double endLat = rs.getDouble(10);</span>
<span class="nc" id="L265">          double endLong = rs.getDouble(11);</span>

          // for printing out ways
<span class="nc" id="L268">          toPrint.add(wayId);</span>

          // node initialization
<span class="nc" id="L271">          WayNodes from = new WayNodes(startId, startLat, startLong, this.conn);</span>
<span class="nc" id="L272">          WayNodes to = new WayNodes(endId, endLat, endLong, this.conn);</span>

          // to do: initialize way between start and end initialization
<span class="nc" id="L275">          Way way = new Way(wayId, from, to, type);</span>
<span class="nc" id="L276">          wayMap.put(wayId, way);</span>
<span class="nc" id="L277">        }</span>
<span class="nc" id="L278">        rs.close();</span>

        // printing way id
        // returning what's in ResultSet
<span class="nc" id="L282">        List&lt;Way&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        for (String id: toPrint) {</span>
<span class="nc" id="L284">          System.out.println(id);</span>
<span class="nc" id="L285">          ret.add(wayMap.get(id));</span>
<span class="nc" id="L286">        }</span>
<span class="nc" id="L287">        return ret;</span>

<span class="nc" id="L289">      } catch (NumberFormatException e) {</span>
        //if the number is not an integer, throw an exception
<span class="nc" id="L291">        System.err.println(&quot;ERROR: Please supply a valid double&quot;);</span>
<span class="nc" id="L292">        return null;</span>
<span class="nc" id="L293">      } catch (SQLException e) {</span>
<span class="nc" id="L294">        System.err.println(&quot;ERROR: Error parsing your input&quot;);</span>
<span class="nc" id="L295">        return null;</span>
      }
    }
  }


  /**
   * This is the implementation of the nearest method.
   * @param coms an array of whitespace split commands
   * @return the nearest Way Node
   */
  public WayNodes nearest(String[] coms) {
<span class="nc bnc" id="L307" title="All 4 branches missed.">    if (wayNodesTree == null || wayNodeList == null) {</span>
<span class="nc" id="L308">      System.err.println(&quot;ERROR: Please load a maps db into the REPL&quot;);</span>
<span class="nc" id="L309">      return null;</span>
    }
<span class="nc bnc" id="L311" title="All 4 branches missed.">    if (wayNodesTree.isEmpty() || wayNodeList.isEmpty()) {</span>
<span class="nc" id="L312">      System.err.println(&quot;ERROR: Please load a maps db into the REPL&quot;);</span>
<span class="nc" id="L313">      return null;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">    } else if (coms.length != 3) {</span>
<span class="nc" id="L315">      System.err.println(&quot;ERROR: Incorrect number or args provided for ways command&quot;);</span>
<span class="nc" id="L316">      return null;</span>
    } else {
      try {
<span class="nc" id="L319">        double lat = Double.parseDouble(coms[1]);</span>
<span class="nc" id="L320">        double longit = Double.parseDouble(coms[2]);</span>
        //check helper method- creates new WayNode
<span class="nc" id="L322">        WayNodes target = this.getWayNodeByLatLong(lat, longit);</span>
        //use our KDTree search method to find nearest neighbor
<span class="nc" id="L324">        List&lt;WayNodes&gt; ret = wayNodesTree.nearestNeighbors(1, target, false);</span>
<span class="nc" id="L325">        WayNodes nearest = ret.get(0);</span>
<span class="nc" id="L326">        wayNodeCache.put(nearest.getId(), nearest);</span>
<span class="nc" id="L327">        System.out.println(nearest.getInfo(&quot;id&quot;));</span>
<span class="nc" id="L328">        return nearest;</span>
<span class="nc" id="L329">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L330">        System.err.println(&quot;ERROR: Please supply a valid double&quot;);</span>
<span class="nc" id="L331">        return null;</span>
      }
    }
  }

  /**
   * This is the implementation of the route method.
   * @param coms an array of whitespace split commands
   */
  private void route(String[] coms) {
    //check if we haven't loaded data
<span class="nc bnc" id="L342" title="All 4 branches missed.">    if (wayNodesTree == null || wayNodeList == null) {</span>
<span class="nc" id="L343">      System.err.println(&quot;ERROR: Please load a maps db into the REPL&quot;);</span>
<span class="nc" id="L344">      return;</span>
    }
<span class="nc bnc" id="L346" title="All 4 branches missed.">    if (wayNodesTree.isEmpty() || wayNodeList.isEmpty()) {</span>
<span class="nc" id="L347">      System.err.println(&quot;ERROR: Please load a maps db into the REPL&quot;);</span>
<span class="nc" id="L348">      return;</span>
    }
<span class="nc bnc" id="L350" title="All 2 branches missed.">    if (coms.length != 5) {</span>
<span class="nc" id="L351">      System.err.println(&quot;ERROR: Incorrect number of args provided for route command&quot;);</span>
<span class="nc" id="L352">      return;</span>
    }
    WayNodes start;
    WayNodes end;
<span class="nc" id="L356">    graph = new Graph&lt;&gt;();</span>
    //street names inputted
<span class="nc bnc" id="L358" title="All 2 branches missed.">    if (!this.isClassInt(coms)) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">      for (int i = 1; i &lt; coms.length; i++) {</span>
        //checking that each argument is a nonempty string
<span class="nc bnc" id="L361" title="All 4 branches missed.">        if (!(coms[i] instanceof String &amp;&amp; coms[i] != &quot;&quot;)) {</span>
<span class="nc" id="L362">          System.err.println(&quot;ERROR: Street names must be nonempty strings&quot;);</span>
<span class="nc" id="L363">          return;</span>
        }
      }
      //check helper methods
<span class="nc" id="L367">      start = getWayNodesAtIntersection(coms[1], coms[2]);</span>
<span class="nc" id="L368">      end = getWayNodesAtIntersection(coms[3], coms[4]);</span>
      //if intersection not found
<span class="nc bnc" id="L370" title="All 4 branches missed.">      if (start == null &amp;&amp; end == null) {</span>
<span class="nc" id="L371">        System.err.println(&quot;ERROR: No intersection found: Both set of streets don't intersect&quot;);</span>
<span class="nc" id="L372">        return;</span>
        //if starting node and ending node are equal, can't find a path
<span class="nc bnc" id="L374" title="All 2 branches missed.">      } else if (start == null) {</span>
<span class="nc" id="L375">        System.err.println(&quot;ERROR: No intersection found: The first two streets don't intersect&quot;);</span>
<span class="nc" id="L376">        return;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">      } else if (end == null) {</span>
<span class="nc" id="L378">        System.err.println(&quot;ERROR: No intersection found: The last two streets don't intersect&quot;);</span>
<span class="nc" id="L379">        return;</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">      } else if (start.equals(end)) {</span>
<span class="nc" id="L381">        System.out.println(&quot;No route found- start and end nodes are the same&quot;);</span>
<span class="nc" id="L382">        return;</span>
      } else {
<span class="nc" id="L384">        String startID = start.getId();</span>
<span class="nc" id="L385">        String endID = end.getId();</span>
<span class="nc" id="L386">        wayNodeCache.put(startID, start);</span>
<span class="nc" id="L387">        wayNodeCache.put(endID, end);</span>
<span class="nc" id="L388">        end = graph.aStar(start, end);</span>
        //no path exists
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (end == null) {</span>
<span class="nc" id="L391">          System.out.println(startID + &quot; -/- &quot; + endID);</span>
<span class="nc" id="L392">          return;</span>
        } else {
          //check helper method, prints to terminal
<span class="nc" id="L395">          this.printRoute(start, end);</span>
        }
<span class="nc" id="L397">      }</span>
      //lat and long inputted
    } else {
      try {
<span class="nc" id="L401">        double lat1 = Double.parseDouble(coms[1]);</span>
<span class="nc" id="L402">        double long1 = Double.parseDouble(coms[2]);</span>
<span class="nc" id="L403">        WayNodes startTarget = this.getWayNodeByLatLong(lat1, long1);</span>
        //find start node using nearestNeighbors
<span class="nc" id="L405">        List&lt;WayNodes&gt; startRet = wayNodesTree.nearestNeighbors(1, startTarget, false);</span>
<span class="nc" id="L406">        start = startRet.get(0);</span>
<span class="nc" id="L407">        double lat2 = Double.parseDouble(coms[3]);</span>
<span class="nc" id="L408">        double long2 = Double.parseDouble(coms[4]);</span>
<span class="nc" id="L409">        WayNodes endTarget = this.getWayNodeByLatLong(lat2, long2);</span>
        //find ending node using nearestNeighbors
<span class="nc" id="L411">        List&lt;WayNodes&gt; endRet = wayNodesTree.nearestNeighbors(1, endTarget, false);</span>
<span class="nc" id="L412">        end = endRet.get(0);</span>
        //if start and end nodes are same, want to print nothing
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (start.equals(end)) {</span>
<span class="nc" id="L415">          System.out.println(&quot;No route found- start and end nodes are the same&quot;);</span>
<span class="nc" id="L416">          return;</span>
        }
<span class="nc" id="L418">        String startID = start.getId();</span>
<span class="nc" id="L419">        String endID = end.getId();</span>
<span class="nc" id="L420">        end = graph.aStar(start, end);</span>
        //no path exists
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (end == null) {</span>
<span class="nc" id="L423">          System.out.println(startID + &quot; -/- &quot; + endID);</span>
<span class="nc" id="L424">          return;</span>
        } else {
          //check helper method, prints to terminal
<span class="nc" id="L427">          this.printRoute(start, end);</span>
        }
<span class="nc" id="L429">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L430">        System.err.println(&quot;ERROR: Latitudes and longitudes must be ints or doubles&quot;);</span>
<span class="nc" id="L431">        return;</span>
<span class="nc" id="L432">      }</span>

    }
<span class="nc" id="L435">  }</span>

  /**
   * This is the implementation of the route method.
   * @param coms an array of whitespace split commands
   * @return a list of routes
   */
  public List&lt;WayNodes&gt; routeRet(String[] coms) {
<span class="nc" id="L443">    List&lt;WayNodes&gt; ret = new ArrayList&lt;&gt;();</span>
    //check if we haven't loaded data
<span class="nc bnc" id="L445" title="All 4 branches missed.">    if (wayNodesTree == null || wayNodeList == null) {</span>
<span class="nc" id="L446">      System.err.println(&quot;ERROR: Please load a maps db into the REPL&quot;);</span>
<span class="nc" id="L447">      return ret;</span>
    }
<span class="nc bnc" id="L449" title="All 4 branches missed.">    if (wayNodesTree.isEmpty() || wayNodeList.isEmpty()) {</span>
<span class="nc" id="L450">      System.err.println(&quot;ERROR: Please load a maps db into the REPL&quot;);</span>
<span class="nc" id="L451">      return ret;</span>
    }
<span class="nc bnc" id="L453" title="All 2 branches missed.">    if (coms.length != 5) {</span>
<span class="nc" id="L454">      System.err.println(&quot;ERROR: Incorrect number of args provided for route command&quot;);</span>
<span class="nc" id="L455">      return ret;</span>
    }
    WayNodes start;
    WayNodes end;
<span class="nc" id="L459">    graph = new Graph&lt;&gt;();</span>
    //street names inputted
<span class="nc bnc" id="L461" title="All 2 branches missed.">    if (!this.isClassInt(coms)) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">      for (int i = 1; i &lt; coms.length; i++) {</span>
        //checking that each argument is a nonempty string
<span class="nc bnc" id="L464" title="All 4 branches missed.">        if (!(coms[i] instanceof String &amp;&amp; coms[i] != &quot;&quot;)) {</span>
<span class="nc" id="L465">          System.err.println(&quot;ERROR: Street names must be nonempty strings&quot;);</span>
<span class="nc" id="L466">          return ret;</span>
        }
      }
      //check helper methods
<span class="nc" id="L470">      start = getWayNodesAtIntersection(coms[1], coms[2]);</span>
<span class="nc" id="L471">      end = getWayNodesAtIntersection(coms[3], coms[4]);</span>
      //if intersection not found
<span class="nc bnc" id="L473" title="All 4 branches missed.">      if (start == null &amp;&amp; end == null) {</span>
<span class="nc" id="L474">        System.err.println(&quot;ERROR: No intersection found: Both set of streets don't intersect&quot;);</span>
<span class="nc" id="L475">        return ret;</span>
        //if starting node and ending node are equal, can't find a path
<span class="nc bnc" id="L477" title="All 2 branches missed.">      } else if (start == null) {</span>
<span class="nc" id="L478">        System.err.println(&quot;ERROR: No intersection found: The first two streets don't intersect&quot;);</span>
<span class="nc" id="L479">        return ret;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">      } else if (end == null) {</span>
<span class="nc" id="L481">        System.err.println(&quot;ERROR: No intersection found: The last two streets don't intersect&quot;);</span>
<span class="nc" id="L482">        return ret;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">      } else if (start.equals(end)) {</span>
<span class="nc" id="L484">        System.out.println(&quot;No route found- start and end nodes are the same&quot;);</span>
<span class="nc" id="L485">        return ret;</span>
      } else {
<span class="nc" id="L487">        String startID = start.getId();</span>
<span class="nc" id="L488">        String endID = end.getId();</span>
<span class="nc" id="L489">        wayNodeCache.put(startID, start);</span>
<span class="nc" id="L490">        wayNodeCache.put(endID, end);</span>
<span class="nc" id="L491">        end = graph.aStar(start, end);</span>
        //no path exists
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (end == null) {</span>
<span class="nc" id="L494">          System.out.println(startID + &quot; -/- &quot; + endID);</span>
<span class="nc" id="L495">          return ret;</span>
        } else {
          //check helper method, prints to terminal
          //this.printRoute(start, end);
<span class="nc" id="L499">          return this.getList(start, end);</span>
        }
      }
      //lat and long inputted
    } else {
      try {
<span class="nc" id="L505">        double lat1 = Double.parseDouble(coms[1]);</span>
<span class="nc" id="L506">        double long1 = Double.parseDouble(coms[2]);</span>
<span class="nc" id="L507">        WayNodes startTarget = this.getWayNodeByLatLong(lat1, long1);</span>
        //find start node using nearestNeighbors
<span class="nc" id="L509">        List&lt;WayNodes&gt; startRet = wayNodesTree.nearestNeighbors(1, startTarget, false);</span>
<span class="nc" id="L510">        start = startRet.get(0);</span>
<span class="nc" id="L511">        double lat2 = Double.parseDouble(coms[3]);</span>
<span class="nc" id="L512">        double long2 = Double.parseDouble(coms[4]);</span>
<span class="nc" id="L513">        WayNodes endTarget = this.getWayNodeByLatLong(lat2, long2);</span>
        //find ending node using nearestNeighbors
<span class="nc" id="L515">        List&lt;WayNodes&gt; endRet = wayNodesTree.nearestNeighbors(1, endTarget, false);</span>
<span class="nc" id="L516">        end = endRet.get(0);</span>
        //if start and end nodes are same, want to print nothing
<span class="nc bnc" id="L518" title="All 2 branches missed.">        if (start.equals(end)) {</span>
<span class="nc" id="L519">          System.out.println(&quot;No route found- start and end nodes are the same&quot;);</span>
<span class="nc" id="L520">          return ret;</span>
        }
<span class="nc" id="L522">        String startID = start.getId();</span>
<span class="nc" id="L523">        String endID = end.getId();</span>
<span class="nc" id="L524">        end = graph.aStar(start, end);</span>
        //no path exists
<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (end == null) {</span>
<span class="nc" id="L527">          System.out.println(startID + &quot; -/- &quot; + endID);</span>
<span class="nc" id="L528">          return ret;</span>
        } else {
          //check helper method, prints to terminal
          //this.printRoute(start, end);
<span class="nc" id="L532">          return this.getList(start, end);</span>
        }
<span class="nc" id="L534">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L535">        System.err.println(&quot;ERROR: Latitudes and longitudes must be ints or doubles&quot;);</span>
<span class="nc" id="L536">        return ret;</span>
      }

    }
  }


  /**.
   * Takes in the command line for naive_neighbors and radius
   * and sees if second arg is an int
   * @param scale string[] of commands
   * @return boolean representing if it takes an int (true if int)
   */
  public boolean isClassInt(String[] scale) {
    try {
<span class="nc" id="L551">      Double.parseDouble(scale[1]);</span>
<span class="nc" id="L552">      return true;</span>
<span class="nc" id="L553">    } catch (NumberFormatException e) {</span>
<span class="nc" id="L554">      return false;</span>
    }
  }


  /**
   * Helper method to print route path to terminal.
   * @param start representing starting WayNode
   * @param end representing ending WayNode
   */
  private void printRoute(WayNodes start, WayNodes end) {
<span class="nc" id="L565">    List&lt;Way&gt; route = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L566">    WayNodes currNode = end;</span>
    //looping through the route, adding ways to list
<span class="nc bnc" id="L568" title="All 2 branches missed.">    while (currNode.getId() != start.getId()) {</span>
<span class="nc" id="L569">      Way currWay = currNode.getFrom();</span>
<span class="nc" id="L570">      route.add(currWay);</span>
<span class="nc" id="L571">      currNode = currWay.getFrom();</span>
<span class="nc" id="L572">    }</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">    for (int i = route.size() - 1; i &gt;= 0; i--) {</span>
      //formatting string to print in terminal
<span class="nc" id="L575">      System.out.println(route.get(i).getFrom().getId() + &quot; -&gt; &quot; + route.get(i).getTo().getId()</span>
<span class="nc" id="L576">              + &quot; : &quot; + route.get(i).getId());</span>
    }
<span class="nc" id="L578">  }</span>

  /**
   * This is a function to get a List of Nodes.
   * @param start the start node we want to get to
   * @param end the end node we want to get to
   * @return list a list of Nodes
   */
  private List&lt;WayNodes&gt; getList(WayNodes start, WayNodes end) {
<span class="nc" id="L587">    List&lt;WayNodes&gt; route = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L588">    WayNodes currNode = end;</span>
<span class="nc" id="L589">    route.add(currNode);</span>
    //looping through the route, adding ways to list
<span class="nc bnc" id="L591" title="All 2 branches missed.">    while (currNode.getId() != start.getId()) {</span>
<span class="nc" id="L592">      Way currWay = currNode.getFrom();</span>
<span class="nc" id="L593">      currNode = currWay.getFrom();</span>
<span class="nc" id="L594">      route.add(currNode);</span>
<span class="nc" id="L595">    }</span>
<span class="nc" id="L596">    Collections.reverse(route);</span>
<span class="nc" id="L597">    return route;</span>
  }

  /**
   * Method to create a WayNode for nearest search, based on specific lat-long pair.
   * @param lat latitude of the point
   * @param longit longitude of the point
   * @return a WayNodes object with those points
   */
  public WayNodes getWayNodeByLatLong(double lat, double longit) {
<span class="nc bnc" id="L607" title="All 2 branches missed.">    for (WayNodes node: wayNodeList) {</span>
<span class="nc bnc" id="L608" title="All 4 branches missed.">      if (Double.compare(node.getLat(), lat) == 0 &amp;&amp; Double.compare(node.getLong(), longit) == 0) {</span>
<span class="nc" id="L609">        return node;</span>
      }
<span class="nc" id="L611">    }</span>
<span class="nc" id="L612">    return new WayNodes(&quot;temp&quot;, lat, longit, this.conn);</span>
  }

  /**
   * Gets a waynode by the string id name using the WayNodeCache.
   * @param s1 the id name
   * @return WayNode found by ID
   */
  public WayNodes getIDByString(String s1) {
<span class="nc bnc" id="L621" title="All 4 branches missed.">    if (s1 == null || s1.equals(&quot;&quot;)) {</span>
<span class="nc" id="L622">      return null;</span>
    } else {
      try {
<span class="nc bnc" id="L625" title="All 2 branches missed.">        if (wayNodeCache.containsKey(s1)) {</span>
<span class="nc" id="L626">          return wayNodeCache.get(s1);</span>
        } else {
<span class="nc" id="L628">          PreparedStatement getNode = conn.prepareStatement(&quot;SELECT * FROM node WHERE node.id = ?&quot;);</span>
<span class="nc" id="L629">          getNode.setString(1, s1);</span>
<span class="nc" id="L630">          ResultSet answer1 = getNode.executeQuery();</span>
<span class="nc" id="L631">          WayNodes ws = null;</span>
          //instantiate WayNode object
<span class="nc bnc" id="L633" title="All 2 branches missed.">          while (answer1.next()) {</span>
<span class="nc" id="L634">            ws = new WayNodes(answer1.getString(1),</span>
<span class="nc" id="L635">              answer1.getDouble(2), answer1.getDouble(3), conn);</span>
<span class="nc" id="L636">            wayNodeCache.put(ws.getId(), ws);</span>
          }
<span class="nc" id="L638">          return ws;</span>
        }
<span class="nc" id="L640">      } catch (SQLException e) {</span>
<span class="nc" id="L641">        return null;</span>
      }
    }
  }



  /**
   * Returns a wayNode at a given intersection street using SQL queries.
   * @param s1 street 1
   * @param s2 street 2
   * @return node at intersection of streets (or null if none exists)
   */
  public WayNodes getWayNodesAtIntersection(String s1, String s2) {
    try {

<span class="nc" id="L657">      PreparedStatement getWay1 = conn.prepareStatement(&quot;WITH street1 AS &quot;</span>
          + &quot;(SELECT start, end FROM way WHERE name = ?), &quot;
          + &quot;cross1 as (SELECT start, end FROM way where name = ?) , &quot;
          + &quot;streetNodes AS (SELECT start AS nodeID FROM street1 UNION SELECT &quot;
          + &quot;end AS nodeID FROM street1)&quot;
          + &quot;, crossNodes AS (SELECT start AS nodeID FROM cross1 UNION SELECT &quot;
          + &quot;end as nodeID from cross1) &quot;
          + &quot;SELECT * FROM streetNodes INNER JOIN crossNodes ON &quot;
          + &quot;streetNodes.nodeID = crossNodes.nodeID&quot;);
<span class="nc" id="L666">      getWay1.setString(1, s1.substring(1, s1.length() - 1));</span>
<span class="nc" id="L667">      getWay1.setString(2, s2.substring(1, s2.length() - 1));</span>
<span class="nc" id="L668">      ResultSet answer1 = getWay1.executeQuery();</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">      while (answer1.next()) {</span>
<span class="nc" id="L670">        String node = answer1.getString(&quot;nodeID&quot;);</span>
<span class="nc" id="L671">        answer1.close();</span>
<span class="nc" id="L672">        return this.getIDByString(node);</span>
      }
<span class="nc" id="L674">      return null;</span>
<span class="nc" id="L675">    } catch (SQLException e) {</span>
<span class="nc" id="L676">      return null;</span>
    }
  }
}


</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>