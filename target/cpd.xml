<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
   <duplication lines="106" tokens="540">
      <file line="78"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/TripGraph/CompleteTripGraph.java"/>
      <file line="45"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/TripGraph/TripGraph.java"/>
      <codefragment><![CDATA[    }
  }

  /**
   * This is a method to run aStar on a graph.
   * @param start the name of the start city
   * @param end the name of the end city.
   * @return a list of nodes to visit
   */
  public List<N> aStar(String start, String end){
    List<N> ret = new ArrayList<>();
    if(!graph.containsKey(start) || !graph.containsKey(end)){
      return null;
    } else if(start.equals(end)){
      ret.add(graph.get(start));
      return ret;
    } else{
      ret = aStarHelper(graph.get(start), graph.get(end));
      return ret;
    }
  }

  /**
   * This is a helper to run aStar within the graph that we are writing
   * @param start the start node to search from
   * @param end the end node to start from
   * @return a list of nodes
   */
  public List<N> aStarHelper(N start, N end){
    ArrayList<N> ret = new ArrayList<>();
    //create a comparator that sorts them by a weight aStar assigns them
    PriorityQueue<N> pq = new PriorityQueue<N>(new TripGraphNodeComparator<N, E>());
    //set the distance travelled to 0
    start.setDistance(0);
    start.setWeight(0);
    //keep track of a visited
    HashMap<String, N> visited = new HashMap<>();
    HashMap<N, List<E>> deletedEdges = new HashMap<>();
    //put them in the visited
    visited.put(start.getName(), start);
    List<N> nodes = new ArrayList<>();
    //nodes.add(start);
    pq.add(start);
    return aStarHelp(end, pq, nodes, visited);
  }

  /**
   * Helper method to conduct the AStar search recursively and use backtracking
   * to save the route, since this method could not be used previously.
   * @param end the end node to search for
   * @param pq priorityqueue to use
   * @param nodes nodes of curr path
   * @param visited map of visited
   * @return a list of Nodes.
   */
  public List<N> aStarHelp(N end, PriorityQueue<N> pq, List<N> nodes, HashMap<String, N> visited){
    if(!pq.isEmpty()){
      N curr = pq.poll();
      nodes.add(curr);
      if (curr.equals(end)) {
        //return a copy in order to prevent alteration
        return new ArrayList<>(nodes);
      }
      List<N> neighbors = curr.getNeighbors();
      for(N next: neighbors){
        if(next.equals(curr)) {
          continue;
        } else{
          String name = next.getName();
          Double dist = curr.getDistance() + curr.getConnectingEdges().get(name).getWeight();
          Double totalWeight = dist + next.toGoal(end);
          if (!visited.containsKey(next.getName())) {
            next.setDistance(dist);
            next.setWeight(totalWeight);
            visited.put(next.getName(), next);
            pq.add(next);
          } else {
            N prev = visited.get(next.getName());
            //checking if we want to update the weight and distance
            if (prev.getWeight() > totalWeight) {
              next.setDistance(dist);
              next.setWeight(totalWeight);
              visited.put(next.getName(), next);
              pq.add(next);
            }
          }
        }
      }
      //backtracking
      List<N> ret = aStarHelp(end, pq, nodes, visited);
      nodes.remove(curr);
      return ret;
    } else{
      if(visited.containsKey(end)){
        return nodes;
      } else{
        return null;
      }
    }
  }

  /**
   * This is used to insert a node into the graph.
   * @param node the node to insert into the graph
   */
  public void insertNode(N node){]]></codefragment>
   </duplication>
   <duplication lines="50" tokens="168">
      <file line="483"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/stars/StarsLogic.java"/>
      <file line="556"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/stars/StarsLogic.java"/>
      <codefragment><![CDATA[    }

    //sort the entries into a list of keys;
    ArrayList<Double> keys = new ArrayList<>(map.keySet());
    //sort the keys in order from descending to ascending
    Collections.sort(keys);
    //a counter to go through the list
    int start = 0;
    //while we still have keys to go through and more neighbors:
    while (start < keys.size() && k > 0) {
      //get the nextClosestStars
      ArrayList<Star> nextClosestStars = map.get(keys.get(start));
      //subtract k
      int size = nextClosestStars.size();
      k -= size;
      //if k is below 0, that means there was
      // overflow by the size - k, so we need to select
      //size - k elements to add
      if (k < 0) {
        for (int i = 0; i < size - Math.abs(k); i++) {
          //generate a randomInt based on the current remaining stars
          int randomInt = (int) (Math.random()
              * (nextClosestStars.size()));
          //add the star
          ret.add(nextClosestStars.get(randomInt));
          //remove it from the list of remaining stars
          nextClosestStars.remove(randomInt);
        }
        //since we have hit k we are done;
        break;
      } else {
        //add the nextStar
        for (Star nextStar: nextClosestStars) {
          ret.add(nextStar);
        }
        //increment start;
        start++;
      }
    }
    //return our arrayList
    return ret;
  }
  /**.
   * Calculates the k nearest neighbors to a star with name
   * @param k Non-negative number of neighbors to find
   * @param name Name of the star
   * @return a List of Stars closest to the Star searched
   * for
   */
  public List<Star> naiveNearestNeighbors(int k, String name) {]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="149">
      <file line="395"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/maps/MapsLogic.java"/>
      <file line="499"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/maps/MapsLogic.java"/>
      <codefragment><![CDATA[          this.printRoute(start, end);
        }
      }
      //lat and long inputted
    } else {
      try {
        double lat1 = Double.parseDouble(coms[1]);
        double long1 = Double.parseDouble(coms[2]);
        WayNodes startTarget = this.getWayNodeByLatLong(lat1, long1);
        //find start node using nearestNeighbors
        List<WayNodes> startRet = wayNodesTree.nearestNeighbors(1, startTarget, false);
        start = startRet.get(0);
        double lat2 = Double.parseDouble(coms[3]);
        double long2 = Double.parseDouble(coms[4]);
        WayNodes endTarget = this.getWayNodeByLatLong(lat2, long2);
        //find ending node using nearestNeighbors
        List<WayNodes> endRet = wayNodesTree.nearestNeighbors(1, endTarget, false);
        end = endRet.get(0);
        //if start and end nodes are same, want to print nothing
        if (start.equals(end)) {
          System.out.println("No route found- start and end nodes are the same");
          return;]]></codefragment>
   </duplication>
   <duplication lines="24" tokens="146">
      <file line="266"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/maps/GUIHandler.java"/>
      <file line="320"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/maps/GUIHandler.java"/>
      <codefragment><![CDATA[            ret += "<br> <br>";
            ret += "<table id=\"table\">"
              + "<tr> <th> Match # </th> <th> Name </th>"
              + "<th> ID </th> <th> X </th> <th> Y </th> <th> Z </th> </tr>";
            for (int i = 0; i < stars.size(); i++) {
              Star curr = stars.get(i);
              ret += "<tr><td>" + Integer.toString(i + 1) + "</td>" + "<td>" + curr.getName()
                + "</td>" + "<td>" + curr.getStarID() + "</td>"
                + "<td>" + curr.getX() + "</td>"
                + "<td>" + curr.getY() + "</td>"
                + "<td>" + curr.getZ() + "</td>";
              ret += "</tr>";
            }
            ret += "</table>";
          } else {
            ret = "No stars found in the search";
          }
        }
      }
      Map<String, Object> variables = ImmutableMap.of("title",
          "Stars: Query the database", "results", ret);
      return new ModelAndView(variables, "query.ftl");
    }
  }]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="144">
      <file line="348"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/stars/StarsLogic.java"/>
      <file line="415"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/stars/StarsLogic.java"/>
      <codefragment><![CDATA[        }
        List<Star> ret = new ArrayList<>();
        if (coms.length == 3) {
          //call nearest_radius with radius/name
          if (!naive) {
            ret = nearestRadius(r, coms[2]);
          } else {
            ret = naiveNearestRadius(r, coms[2]);
          }
        } else {
          double x = Double.parseDouble(coms[2]);
          double y = Double.parseDouble(coms[3]);
          double z = Double.parseDouble(coms[4]);
          if (!naive) {
            ret = nearestRadius(r, x, y, z);
          } else {
            ret = naiveNearestRadius(r, x, y, z);
          }
        }
        if (ret == null) {
          System.err.println("ERROR: Invalid Search");
          return null;]]></codefragment>
   </duplication>
   <duplication lines="22" tokens="132">
      <file line="200"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/stars/StarsLogic.java"/>
      <file line="271"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/stars/StarsLogic.java"/>
      <codefragment><![CDATA[        }
        //call different helpers based on args supplied
        if (coms.length == 3) {
          if (!naive) {
            ret = nearestNeighbors(knn, coms[2]);
          } else {
            ret = naiveNearestNeighbors(knn, coms[2]);
          }
          //print every star in the returned list
        } else {
          double x = Double.parseDouble(coms[2]);
          double y = Double.parseDouble(coms[3]);
          double z = Double.parseDouble(coms[4]);
          if (!naive) {
            ret = nearestNeighbors(knn, x, y, z);
          } else {
            ret = naiveNearestNeighbors(knn, x, y, z);
          }
        }
        if (ret == null) {
          System.err.println("ERROR: INVALID SEARCH");
          return null;]]></codefragment>
   </duplication>
   <duplication lines="19" tokens="111">
      <file line="210"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/TripGraph/CityNode.java"/>
      <file line="246"
            path="/Users/onrmmm78/Desktop/csci0320/term-project-dsegel-hsowerby-mramesh4-sraman9/src/main/java/edu/brown/cs/mramesh4/maps/WayNodes.java"/>
      <codefragment><![CDATA[    double thisLon = Math.toRadians(longit);
    double goalLat = Math.toRadians(goal.getLat());
    double goalLon = Math.toRadians(goal.getLong());
    /**
     * Haversine formula: I got this from
     * https://www.geeksforgeeks.org/program-distance-two-points-earth/
     */
    double dlon = goalLon - thisLon;
    double dlat = goalLat - thisLat;
    double havernmath = Math.pow(Math.sin(dlat / 2), 2)
        + Math.cos(thisLat) * Math.cos(goalLat)
        * Math.pow(Math.sin(dlon / 2), 2);
    double finalanswer = 2 * Math.asin(Math.sqrt(havernmath));
    // Radius of earth in kilometers. Use 3956 for miles
    return (finalanswer * EARTH_RADIUS_IN_KM);
  }


}]]></codefragment>
   </duplication>
</pmd-cpd>